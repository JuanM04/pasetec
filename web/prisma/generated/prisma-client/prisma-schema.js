module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateLog {
  count: Int!
}

type AggregateMetadata {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

type Log {
  id: ID!
  user: User!
  type: LogType!
  date: DateTime!
  data: Json
}

type LogConnection {
  pageInfo: PageInfo!
  edges: [LogEdge]!
  aggregate: AggregateLog!
}

input LogCreateInput {
  id: ID
  user: UserCreateOneInput!
  type: LogType!
  date: DateTime!
  data: Json
}

type LogEdge {
  node: Log!
  cursor: String!
}

enum LogOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  data_ASC
  data_DESC
}

type LogPreviousValues {
  id: ID!
  type: LogType!
  date: DateTime!
  data: Json
}

type LogSubscriptionPayload {
  mutation: MutationType!
  node: Log
  updatedFields: [String!]
  previousValues: LogPreviousValues
}

input LogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogWhereInput
  AND: [LogSubscriptionWhereInput!]
  OR: [LogSubscriptionWhereInput!]
  NOT: [LogSubscriptionWhereInput!]
}

enum LogType {
  USER_CREATED
  USER_UPDATED
  VIAJE_USED
  VIAJES_ADDED
}

input LogUpdateInput {
  user: UserUpdateOneRequiredInput
  type: LogType
  date: DateTime
  data: Json
}

input LogUpdateManyMutationInput {
  type: LogType
  date: DateTime
  data: Json
}

input LogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  type: LogType
  type_not: LogType
  type_in: [LogType!]
  type_not_in: [LogType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [LogWhereInput!]
  OR: [LogWhereInput!]
  NOT: [LogWhereInput!]
}

input LogWhereUniqueInput {
  id: ID
}

scalar Long

type Metadata {
  id: ID!
  date: DateTime!
  pasePrice: Int
  viajePrice: Int
}

type MetadataConnection {
  pageInfo: PageInfo!
  edges: [MetadataEdge]!
  aggregate: AggregateMetadata!
}

input MetadataCreateInput {
  id: ID
  date: DateTime!
  pasePrice: Int
  viajePrice: Int
}

type MetadataEdge {
  node: Metadata!
  cursor: String!
}

enum MetadataOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  pasePrice_ASC
  pasePrice_DESC
  viajePrice_ASC
  viajePrice_DESC
}

type MetadataPreviousValues {
  id: ID!
  date: DateTime!
  pasePrice: Int
  viajePrice: Int
}

type MetadataSubscriptionPayload {
  mutation: MutationType!
  node: Metadata
  updatedFields: [String!]
  previousValues: MetadataPreviousValues
}

input MetadataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetadataWhereInput
  AND: [MetadataSubscriptionWhereInput!]
  OR: [MetadataSubscriptionWhereInput!]
  NOT: [MetadataSubscriptionWhereInput!]
}

input MetadataUpdateInput {
  date: DateTime
  pasePrice: Int
  viajePrice: Int
}

input MetadataUpdateManyMutationInput {
  date: DateTime
  pasePrice: Int
  viajePrice: Int
}

input MetadataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  pasePrice: Int
  pasePrice_not: Int
  pasePrice_in: [Int!]
  pasePrice_not_in: [Int!]
  pasePrice_lt: Int
  pasePrice_lte: Int
  pasePrice_gt: Int
  pasePrice_gte: Int
  viajePrice: Int
  viajePrice_not: Int
  viajePrice_in: [Int!]
  viajePrice_not_in: [Int!]
  viajePrice_lt: Int
  viajePrice_lte: Int
  viajePrice_gt: Int
  viajePrice_gte: Int
  AND: [MetadataWhereInput!]
  OR: [MetadataWhereInput!]
  NOT: [MetadataWhereInput!]
}

input MetadataWhereUniqueInput {
  id: ID
}

type Mutation {
  createLog(data: LogCreateInput!): Log!
  updateLog(data: LogUpdateInput!, where: LogWhereUniqueInput!): Log
  updateManyLogs(data: LogUpdateManyMutationInput!, where: LogWhereInput): BatchPayload!
  upsertLog(where: LogWhereUniqueInput!, create: LogCreateInput!, update: LogUpdateInput!): Log!
  deleteLog(where: LogWhereUniqueInput!): Log
  deleteManyLogs(where: LogWhereInput): BatchPayload!
  createMetadata(data: MetadataCreateInput!): Metadata!
  updateMetadata(data: MetadataUpdateInput!, where: MetadataWhereUniqueInput!): Metadata
  updateManyMetadatas(data: MetadataUpdateManyMutationInput!, where: MetadataWhereInput): BatchPayload!
  upsertMetadata(where: MetadataWhereUniqueInput!, create: MetadataCreateInput!, update: MetadataUpdateInput!): Metadata!
  deleteMetadata(where: MetadataWhereUniqueInput!): Metadata
  deleteManyMetadatas(where: MetadataWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  log(where: LogWhereUniqueInput!): Log
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log]!
  logsConnection(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogConnection!
  metadata(where: MetadataWhereUniqueInput!): Metadata
  metadatas(where: MetadataWhereInput, orderBy: MetadataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Metadata]!
  metadatasConnection(where: MetadataWhereInput, orderBy: MetadataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetadataConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  log(where: LogSubscriptionWhereInput): LogSubscriptionPayload
  metadata(where: MetadataSubscriptionWhereInput): MetadataSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  uid: String!
  dni: Int!
  viajes: Int
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  uid: String!
  dni: Int!
  viajes: Int
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  uid_ASC
  uid_DESC
  dni_ASC
  dni_DESC
  viajes_ASC
  viajes_DESC
}

type UserPreviousValues {
  id: ID!
  uid: String!
  dni: Int!
  viajes: Int
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  uid: String
  dni: Int
  viajes: Int
}

input UserUpdateInput {
  uid: String
  dni: Int
  viajes: Int
}

input UserUpdateManyMutationInput {
  uid: String
  dni: Int
  viajes: Int
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uid: String
  uid_not: String
  uid_in: [String!]
  uid_not_in: [String!]
  uid_lt: String
  uid_lte: String
  uid_gt: String
  uid_gte: String
  uid_contains: String
  uid_not_contains: String
  uid_starts_with: String
  uid_not_starts_with: String
  uid_ends_with: String
  uid_not_ends_with: String
  dni: Int
  dni_not: Int
  dni_in: [Int!]
  dni_not_in: [Int!]
  dni_lt: Int
  dni_lte: Int
  dni_gt: Int
  dni_gte: Int
  viajes: Int
  viajes_not: Int
  viajes_in: [Int!]
  viajes_not_in: [Int!]
  viajes_lt: Int
  viajes_lte: Int
  viajes_gt: Int
  viajes_gte: Int
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  uid: String
  dni: Int
}
`
      }
    